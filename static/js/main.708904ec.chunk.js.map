{"version":3,"sources":["Node/Node.jsx","Algorithms /Dijkstra.jsx","Algorithms /A*.jsx","Grid/Grid.jsx","App.jsx","serviceWorker.js","index.jsx"],"names":["Node","props","useState","row","setRow","col","setCol","isStart","setStart","isFinish","setFinish","isWall","setWall","isVisited","setVisited","isPath","setPath","useEffect","extraClassName","className","onMouseEnter","mouseEnter","onMouseDown","mouseDown","onMouseLeave","mouseLeave","updateNeighbors","node","grid","visited","neighbors","getNeighbors","neighbor","distance","previousNode","push","length","filter","includes","getUnvisitedNodes","nodes","sortNodesByDistance","unvisited","sort","nodeA","nodeB","sortNodesByCost","totalCost","finishNode","heuristic","getHeuristic","Math","pow","sqrt","Grid","createGrid","setGrid","startRow","startCol","finishRow","finishCol","mousePressed","setMousePressed","moveStart","setMoveStart","moveFinish","setMoveFinish","handleMouseDown","handleToggleWall","handleMouseEnter","handleStartEnter","handleFinishEnter","handleMouseLeave","handleStartLeave","handleFinishLeave","newGrid","moveStartNode","moveFinishNode","visualizeDijkstra","startNode","visitedNodes","closestNode","shift","Infinity","dijkstra","shortestPath","currNode","unshift","getShortestPath","animateDijkstra","i","setTimeout","undefined","animateShortestPath","visualizeAStar","aStar","getShortestPathAstar","onMouseUp","onClick","map","rowIdx","key","nodeIdx","App","setStartRow","setStartCol","setFinishRow","setFinishCol","createNode","rows","cols","currRow","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.708904ec.chunk.js","sourcesContent":["import React, { useState, useEffect } from \"react\";\nimport \"./Node.css\";\n// #09d3ac;\nconst Node = props => {\n  const [row, setRow] = useState(0);\n  const [col, setCol] = useState(0);\n  const [isStart, setStart] = useState(false);\n  const [isFinish, setFinish] = useState(false);\n  const [isWall, setWall] = useState(false);\n  const [isVisited, setVisited] = useState(false);\n  const [isPath, setPath] = useState(false);\n\n  useEffect(() => {\n    setCol(props.col);\n    setRow(props.row);\n    setStart(props.isStart);\n    setFinish(props.isFinish);\n    setWall(props.isWall);\n    setVisited(props.isVisited);\n    setPath(props.isPath);\n  }, [\n    props.col,\n    props.row,\n    props.isStart,\n    props.isFinish,\n    props.isWall,\n    props.isVisited,\n    props.isPath\n  ]);\n\n  const extraClassName = isFinish\n    ? \"node-finish\"\n    : isStart\n    ? \"node-start\"\n    : isWall\n    ? \"node-wall\"\n    : isVisited\n    ? \"node-visited\"\n    : isPath\n    ? \"node-path\"\n    : \"\";\n\n  return (\n    <div\n      className={`Node ${extraClassName}`}\n      onMouseEnter={() => props.mouseEnter(row, col)}\n      onMouseDown={() => props.mouseDown(row, col)}\n      onMouseLeave={() => props.mouseLeave(row, col)}\n    ></div>\n  );\n};\n\nexport default Node;\n","// visited\n// unvisited\n// start node\n// finish node\n// wall\n// trapped\n// shortest path\n//set timeout for\nexport function dijkstra(grid, startNode, finishNode) {\n  let unvisited = getUnvisitedNodes(grid);\n  startNode.distance = 0;\n  let visited = [];\n  while (!!unvisited.length) {\n    sortNodesByDistance(unvisited);\n    const closestNode = unvisited.shift();\n    // encounter a wall\n    if (closestNode.isWall) continue;\n    //if closest node is Infinity then trapped\n    if (closestNode.distance === Infinity) return visited;\n    // visited then push\n    visited.push(closestNode);\n    //if finish then return visited\n    if (closestNode === finishNode) return visited;\n    updateNeighbors(closestNode, grid, visited);\n  }\n}\n\nexport function getShortestPath(finishNode) {\n  const shortestPath = [];\n  let currNode = finishNode;\n  while (currNode !== null) {\n    shortestPath.unshift(currNode);\n    currNode = currNode.previousNode;\n  }\n  return shortestPath;\n}\n\nconst updateNeighbors = (node, grid, visited) => {\n  const neighbors = getNeighbors(node, grid, visited);\n  for (const neighbor of neighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n};\n\nconst getNeighbors = (node, grid, visited) => {\n  let neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => {\n    let bool = visited.includes(neighbor);\n    if (bool === false) return neighbor;\n  });\n};\n\nconst getUnvisitedNodes = grid => {\n  let nodes = [];\n  for (let row of grid) {\n    for (let node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\nconst sortNodesByDistance = unvisited => {\n  unvisited.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n};\n","export function aStar(grid, startNode, finishNode) {\n  const visited = [];\n  const unvisited = getUnvisitedNodes(grid);\n  startNode.distance = 0;\n  startNode.totalCost = 0;\n  while (!!unvisited.length) {\n    sortNodesByCost(unvisited);\n    const closestNode = unvisited.shift();\n    // encounter a wall\n    if (closestNode.isWall) continue;\n    //if closest node is Infinity then trapped\n    if (closestNode.distance === Infinity) return visited;\n    // visited then push\n    visited.push(closestNode);\n    //if finish then return visited\n    if (closestNode === finishNode) return visited;\n    updateNeighbors(closestNode, grid, visited, finishNode);\n  }\n}\nconst sortNodesByCost = unvisited => {\n  unvisited.sort((nodeA, nodeB) => nodeA.totalCost - nodeB.totalCost);\n};\n\nconst updateNeighbors = (node, grid, visited, finishNode) => {\n  const neighbors = getNeighbors(node, grid, visited);\n  for (const neighbor of neighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n    neighbor.heuristic = getHeuristic(neighbor, finishNode);\n    neighbor.totalCost = neighbor.heuristic + neighbor.distance;\n    neighbor.previousNode = node;\n  }\n  return neighbors;\n};\n\nconst getHeuristic = (node, finishNode) => {\n  let heuristic = 0;\n  const { row, col } = node;\n  const a = Math.pow(finishNode.row - row, 2);\n  const b = Math.pow(finishNode.col - col, 2);\n  heuristic = a + b;\n  return Math.sqrt(heuristic);\n};\n\nconst getNeighbors = (node, grid, visited) => {\n  let neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => {\n    let bool = visited.includes(neighbor);\n    if (bool === false) return neighbor;\n  });\n};\n\nconst getUnvisitedNodes = grid => {\n  let nodes = [];\n  for (let row of grid) {\n    for (let node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n};\n\nexport function getShortestPathAstar(finishNode) {\n  const shortestPath = [];\n  let currNode = finishNode;\n  while (currNode !== null) {\n    shortestPath.unshift(currNode);\n    currNode = currNode.previousNode;\n  }\n  return shortestPath;\n}\n","import React, { useState, useEffect } from \"react\";\nimport Node from \"../Node/Node\";\nimport \"./Grid.css\";\nimport { dijkstra, getShortestPath } from \"../Algorithms /Dijkstra\";\nimport { aStar, getShortestPathAstar } from \"../Algorithms /A*\";\n\nconst Grid = props => {\n  // create the grid\n  const [grid, setGrid] = useState(props.createGrid(20, 20));\n  // startNode & endNode\n  const startRow = props.startRow;\n  const startCol = props.startCol;\n  const finishRow = props.finishRow;\n  const finishCol = props.finishCol;\n\n  //handle mouse events\n  const [mousePressed, setMousePressed] = useState(false);\n  const [moveStart, setMoveStart] = useState(false);\n  const [moveFinish, setMoveFinish] = useState(false);\n\n  const handleMouseDown = (row, col) => {\n    setMousePressed(true);\n    let node = grid[row][col];\n    if (!node.isStart && !node.isFinish) handleToggleWall(row, col);\n    if (node.isStart) setMoveStart(true);\n    if (node.isFinish) setMoveFinish(true);\n  };\n\n  const handleMouseUp = () => {\n    setMousePressed(false);\n    setMoveStart(false);\n    setMoveFinish(false);\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (mousePressed && !moveStart && !moveFinish) handleToggleWall(row, col);\n    if (mousePressed && moveStart && !moveFinish) handleStartEnter(row, col);\n    if (mousePressed && !moveStart && moveFinish) handleFinishEnter(row, col);\n  };\n\n  const handleMouseLeave = (row, col) => {\n    if (mousePressed && moveStart) handleStartLeave(row, col);\n    if (mousePressed && moveFinish) handleFinishLeave(row, col);\n  };\n\n  const handleStartEnter = (row, col) => {\n    let newGrid = [...grid];\n    let node = newGrid[row][col];\n    node.isStart = true;\n    props.moveStartNode(row, col);\n    setGrid(newGrid);\n  };\n\n  const handleStartLeave = (row, col) => {\n    let newGrid = [...grid];\n    let node = newGrid[row][col];\n    node.isStart = false;\n    setGrid(newGrid);\n  };\n\n  const handleFinishEnter = (row, col) => {\n    let newGrid = [...grid];\n    let node = newGrid[row][col];\n    node.isFinish = true;\n    props.moveFinishNode(row, col);\n    setGrid(newGrid);\n  };\n\n  const handleFinishLeave = (row, col) => {\n    let newGrid = [...grid];\n    let node = newGrid[row][col];\n    node.isFinish = false;\n    setGrid(newGrid);\n  };\n\n  const handleToggleWall = (row, col) => {\n    let newGrid = [...grid];\n    let node = newGrid[row][col];\n    node.isWall = node.isWall ? false : true;\n    setGrid(newGrid);\n  };\n\n  const visualizeDijkstra = () => {\n    const startNode = grid[startRow][startCol];\n    const finishNode = grid[finishRow][finishCol];\n    const visitedNodes = dijkstra(grid, startNode, finishNode, setGrid);\n    const shortestPath = getShortestPath(finishNode);\n    animateDijkstra(visitedNodes, shortestPath);\n  };\n\n  const animateDijkstra = (visitedNodes, shortestPath) => {\n    for (let i = 0; i <= visitedNodes.length; i++) {\n      setTimeout(function timer() {\n        if (visitedNodes[i] !== undefined) {\n          visitedNodes[i].isVisited = true;\n          setGrid([...grid]);\n          if (visitedNodes[i].isFinish === true) {\n            animateShortestPath(shortestPath);\n          }\n        }\n      }, i * 30);\n    }\n  };\n\n  const animateShortestPath = shortestPath => {\n    for (let i = 1; i <= shortestPath.length; i++) {\n      setTimeout(function timer() {\n        if (shortestPath[i] !== undefined) {\n          shortestPath[i].isVisited = false;\n          shortestPath[i].isPath = true;\n          setGrid([...grid]);\n        }\n      }, i * 50);\n    }\n  };\n\n  const visualizeAStar = () => {\n    const startNode = grid[startRow][startCol];\n    const finishNode = grid[finishRow][finishCol];\n    const visitedNodes = aStar(grid, startNode, finishNode);\n    const shortestPath = getShortestPathAstar(finishNode);\n    animateDijkstra(visitedNodes, shortestPath);\n  };\n\n  return (\n    <div className=\"pathfinder-wrapper\" onMouseUp={() => handleMouseUp()}>\n      <button\n        onClick={() => {\n          visualizeDijkstra();\n        }}\n      >\n        visualizeDijkstra\n      </button>\n      <button\n        onClick={() => {\n          visualizeAStar();\n        }}\n      >\n        visualize AStar\n      </button>\n\n      <div className=\"Grid\">\n        {grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx} className=\"Row\">\n              {row.map((node, nodeIdx) => {\n                const {\n                  row,\n                  col,\n                  isFinish,\n                  isStart,\n                  isWall,\n                  isVisited,\n                  isPath\n                } = node;\n                return (\n                  <Node\n                    key={nodeIdx}\n                    row={row}\n                    col={col}\n                    isStart={isStart}\n                    isFinish={isFinish}\n                    isWall={isWall}\n                    isVisited={isVisited}\n                    isPath={isPath}\n                    mouseDown={handleMouseDown}\n                    mouseEnter={handleMouseEnter}\n                    mouseLeave={handleMouseLeave}\n                  />\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </div>\n  );\n};\n\nexport default Grid;\n","import React, { useState } from \"react\";\nimport \"./App.css\";\nimport Grid from \"./Grid/Grid\";\nfunction App() {\n  const [startRow, setStartRow] = useState(5);\n  const [startCol, setStartCol] = useState(5);\n  const [finishRow, setFinishRow] = useState(15);\n  const [finishCol, setFinishCol] = useState(15);\n\n  const createNode = (row, col) => {\n    return {\n      col,\n      distance: Infinity,\n      row,\n      isFinish: row === finishRow && col === finishCol,\n      isPath: false,\n      isStart: row === startRow && col === startCol,\n      isVisited: false,\n      isWall: false,\n      previousNode: null,\n      totalCost: Infinity,\n      heuristic: Infinity\n    };\n  };\n\n  const handleCreateGrid = (rows, cols) => {\n    let grid = [];\n    for (let row = 0; row < rows; row++) {\n      let currRow = [];\n      for (let col = 0; col < cols; col++) {\n        currRow.push(createNode(row, col));\n      }\n      grid.push(currRow);\n    }\n    return grid;\n  };\n\n  const handleMoveStartNode = (row, col) => {\n    setStartRow(row);\n    setStartCol(col);\n  };\n\n  const handleMoveFinishNode = (row, col) => {\n    setFinishRow(row);\n    setFinishCol(col);\n  };\n  return (\n    <div className=\"App\">\n      <Grid\n        createGrid={handleCreateGrid}\n        startRow={startRow}\n        startCol={startCol}\n        finishRow={finishRow}\n        finishCol={finishCol}\n        moveStartNode={handleMoveStartNode}\n        moveFinishNode={handleMoveFinishNode}\n      />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}